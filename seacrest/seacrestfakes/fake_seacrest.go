// Code generated by counterfeiter. DO NOT EDIT.
package seacrestfakes

import (
	"sync"

	"github.com/agemmell/banking-cqrs-es-go/seacrest"
	uuid "github.com/nu7hatch/gouuid"
)

type FakeSeacrest struct {
	CreateMessageOfTypeStub        func(string) (seacrest.MessageDescriber, error)
	createMessageOfTypeMutex       sync.RWMutex
	createMessageOfTypeArgsForCall []struct {
		arg1 string
	}
	createMessageOfTypeReturns struct {
		result1 seacrest.MessageDescriber
		result2 error
	}
	createMessageOfTypeReturnsOnCall map[int]struct {
		result1 seacrest.MessageDescriber
		result2 error
	}
	CreateUUIDStub        func() (*uuid.UUID, error)
	createUUIDMutex       sync.RWMutex
	createUUIDArgsForCall []struct {
	}
	createUUIDReturns struct {
		result1 *uuid.UUID
		result2 error
	}
	createUUIDReturnsOnCall map[int]struct {
		result1 *uuid.UUID
		result2 error
	}
	CreateUUIDStringStub        func() (string, error)
	createUUIDStringMutex       sync.RWMutex
	createUUIDStringArgsForCall []struct {
	}
	createUUIDStringReturns struct {
		result1 string
		result2 error
	}
	createUUIDStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSeacrest) CreateMessageOfType(arg1 string) (seacrest.MessageDescriber, error) {
	fake.createMessageOfTypeMutex.Lock()
	ret, specificReturn := fake.createMessageOfTypeReturnsOnCall[len(fake.createMessageOfTypeArgsForCall)]
	fake.createMessageOfTypeArgsForCall = append(fake.createMessageOfTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateMessageOfType", []interface{}{arg1})
	fake.createMessageOfTypeMutex.Unlock()
	if fake.CreateMessageOfTypeStub != nil {
		return fake.CreateMessageOfTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createMessageOfTypeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSeacrest) CreateMessageOfTypeCallCount() int {
	fake.createMessageOfTypeMutex.RLock()
	defer fake.createMessageOfTypeMutex.RUnlock()
	return len(fake.createMessageOfTypeArgsForCall)
}

func (fake *FakeSeacrest) CreateMessageOfTypeCalls(stub func(string) (seacrest.MessageDescriber, error)) {
	fake.createMessageOfTypeMutex.Lock()
	defer fake.createMessageOfTypeMutex.Unlock()
	fake.CreateMessageOfTypeStub = stub
}

func (fake *FakeSeacrest) CreateMessageOfTypeArgsForCall(i int) string {
	fake.createMessageOfTypeMutex.RLock()
	defer fake.createMessageOfTypeMutex.RUnlock()
	argsForCall := fake.createMessageOfTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSeacrest) CreateMessageOfTypeReturns(result1 seacrest.MessageDescriber, result2 error) {
	fake.createMessageOfTypeMutex.Lock()
	defer fake.createMessageOfTypeMutex.Unlock()
	fake.CreateMessageOfTypeStub = nil
	fake.createMessageOfTypeReturns = struct {
		result1 seacrest.MessageDescriber
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) CreateMessageOfTypeReturnsOnCall(i int, result1 seacrest.MessageDescriber, result2 error) {
	fake.createMessageOfTypeMutex.Lock()
	defer fake.createMessageOfTypeMutex.Unlock()
	fake.CreateMessageOfTypeStub = nil
	if fake.createMessageOfTypeReturnsOnCall == nil {
		fake.createMessageOfTypeReturnsOnCall = make(map[int]struct {
			result1 seacrest.MessageDescriber
			result2 error
		})
	}
	fake.createMessageOfTypeReturnsOnCall[i] = struct {
		result1 seacrest.MessageDescriber
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) CreateUUID() (*uuid.UUID, error) {
	fake.createUUIDMutex.Lock()
	ret, specificReturn := fake.createUUIDReturnsOnCall[len(fake.createUUIDArgsForCall)]
	fake.createUUIDArgsForCall = append(fake.createUUIDArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateUUID", []interface{}{})
	fake.createUUIDMutex.Unlock()
	if fake.CreateUUIDStub != nil {
		return fake.CreateUUIDStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createUUIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSeacrest) CreateUUIDCallCount() int {
	fake.createUUIDMutex.RLock()
	defer fake.createUUIDMutex.RUnlock()
	return len(fake.createUUIDArgsForCall)
}

func (fake *FakeSeacrest) CreateUUIDCalls(stub func() (*uuid.UUID, error)) {
	fake.createUUIDMutex.Lock()
	defer fake.createUUIDMutex.Unlock()
	fake.CreateUUIDStub = stub
}

func (fake *FakeSeacrest) CreateUUIDReturns(result1 *uuid.UUID, result2 error) {
	fake.createUUIDMutex.Lock()
	defer fake.createUUIDMutex.Unlock()
	fake.CreateUUIDStub = nil
	fake.createUUIDReturns = struct {
		result1 *uuid.UUID
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) CreateUUIDReturnsOnCall(i int, result1 *uuid.UUID, result2 error) {
	fake.createUUIDMutex.Lock()
	defer fake.createUUIDMutex.Unlock()
	fake.CreateUUIDStub = nil
	if fake.createUUIDReturnsOnCall == nil {
		fake.createUUIDReturnsOnCall = make(map[int]struct {
			result1 *uuid.UUID
			result2 error
		})
	}
	fake.createUUIDReturnsOnCall[i] = struct {
		result1 *uuid.UUID
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) CreateUUIDString() (string, error) {
	fake.createUUIDStringMutex.Lock()
	ret, specificReturn := fake.createUUIDStringReturnsOnCall[len(fake.createUUIDStringArgsForCall)]
	fake.createUUIDStringArgsForCall = append(fake.createUUIDStringArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateUUIDString", []interface{}{})
	fake.createUUIDStringMutex.Unlock()
	if fake.CreateUUIDStringStub != nil {
		return fake.CreateUUIDStringStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createUUIDStringReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSeacrest) CreateUUIDStringCallCount() int {
	fake.createUUIDStringMutex.RLock()
	defer fake.createUUIDStringMutex.RUnlock()
	return len(fake.createUUIDStringArgsForCall)
}

func (fake *FakeSeacrest) CreateUUIDStringCalls(stub func() (string, error)) {
	fake.createUUIDStringMutex.Lock()
	defer fake.createUUIDStringMutex.Unlock()
	fake.CreateUUIDStringStub = stub
}

func (fake *FakeSeacrest) CreateUUIDStringReturns(result1 string, result2 error) {
	fake.createUUIDStringMutex.Lock()
	defer fake.createUUIDStringMutex.Unlock()
	fake.CreateUUIDStringStub = nil
	fake.createUUIDStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) CreateUUIDStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.createUUIDStringMutex.Lock()
	defer fake.createUUIDStringMutex.Unlock()
	fake.CreateUUIDStringStub = nil
	if fake.createUUIDStringReturnsOnCall == nil {
		fake.createUUIDStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createUUIDStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSeacrest) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMessageOfTypeMutex.RLock()
	defer fake.createMessageOfTypeMutex.RUnlock()
	fake.createUUIDMutex.RLock()
	defer fake.createUUIDMutex.RUnlock()
	fake.createUUIDStringMutex.RLock()
	defer fake.createUUIDStringMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSeacrest) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ seacrest.Seacrest = new(FakeSeacrest)
